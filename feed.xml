<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-04-30T18:02:13-03:00</updated><id>http://localhost:4000/</id><title type="html">Adler Neves</title><subtitle>Este é apenas mais um blog na internet, portanto não dê muita importância para ele.
</subtitle><entry><title type="html">“Quem faz malfeito faz duas vezes”? Ou três? Ou quatro? Quantas?</title><link href="http://localhost:4000/paulinho/les20171/2017/04/30/quem-faz-malfeito-faz-duas-vezes.html" rel="alternate" type="text/html" title="&quot;Quem faz malfeito faz duas vezes&quot;? Ou três? Ou quatro? Quantas?" /><published>2017-04-30T12:41:25-03:00</published><updated>2017-04-30T12:41:25-03:00</updated><id>http://localhost:4000/paulinho/les20171/2017/04/30/quem-faz-malfeito-faz-duas-vezes</id><content type="html" xml:base="http://localhost:4000/paulinho/les20171/2017/04/30/quem-faz-malfeito-faz-duas-vezes.html">&lt;p&gt;Inspirado &lt;a href=&quot;https://medium.com/desenvolvimento-%C3%A1gil/a-nova-metodologia-69b8f8a379c7&quot;&gt;num artigo escrito no Medium&lt;/a&gt;, este post falará o óbvio que “todos” sabem (ou deveriam) e até é ditado popular, mas ignoram mesmo assim: “quem faz malfeito faz duas vezes”.&lt;/p&gt;

&lt;p&gt;O desenvolvimento de um software visa resolver um problema, que tem suas peculiaridades. Nada pior que uma “estimativa otimista demais” para começar o desenvolvimento dum software. Metodologias tradicionais geralmente possuem um caráter prescritivo, algo que é fácil de escrever num contrato, mas que não dá flexibilidade à equipe de desenvolvimento ou ao contratante em alterar requisitos. Metodologias ágeis vieram para fornecer princípios que flexibilizam o projeto de desenvolvimento do software, tornando-o mais reativo e menos preditivo.&lt;/p&gt;

&lt;p&gt;De acordo com o Project Smart, apenas &lt;a href=&quot;https://www.projectsmart.co.uk/the-curious-case-of-the-chaos-report-2009.php&quot;&gt;16%&lt;/a&gt; dos projetos de software obtiveram sucesso em 1994 e em 2012 tal taxa era &lt;a href=&quot;https://www.projectsmart.co.uk/cutting-through-the-chaos.php&quot;&gt;39%&lt;/a&gt;. Sem dúvida o cenário melhorou muito, onde neste intervalo a linguagem de programação Java foi introduzida no mercado em 1995, o Extreme Programming foi primeiramente apresentado em 1999, o UML foi aceito pela ISO em 2000, o Manifesto para Desenvolvimento Ágil de Software foi publicado em 2001, o PHP ganhou suporte “completo” a orientação a objetos (é o que diz a &lt;a href=&quot;http://php.net/manual/pt_BR/oop5.intro.php&quot;&gt;documentação&lt;/a&gt;) em 2004, o SonarQube for lançado em 2007, o NodeJS foi lançado em 2009, dentre vários outros acontecimentos no mundo de desenvolvimento de software. Entretanto, 4 em 10 ainda é uma taxa de sucesso baixa, restando espaço para melhorias; mas nem todo fracasso é culpa da metodologia.&lt;/p&gt;

&lt;p&gt;Observando práticas de codificação em plataformas de fórum open-source e closed-source notei que decisões de projeto equivocadas que comprometem a extensibilidade da plataforma levam à completa reescrita da solução quando a adição dum recurso torna-se imprescindível ou sua manutenção torna-se custosa.&lt;/p&gt;

&lt;p&gt;Considerando como erro de projeto toda decisão que limita o software mas mesmo assim é escolhida pois é o caminho de menor esforço, um exemplo a não ser seguido é a plataforma (paga) de fóruns XenForo, que em sua versão 1.x.x (2010 em diante) não possuía classes de aplicação (componente de gerência de tarefas) e mantinha a maior parte de suas regras de negócio nos controladores do padrão MVC (que vincula a URL à classe e seu método), o que forçava duplicação de código e dificultava e às vezes até impedia a criação de microserviços. Na versão 2.x.x (2016 em diante), sob o pretexto de um código mais conciso, coerente e limpo, reimplementaram tudo do zero.&lt;/p&gt;

&lt;p&gt;Na nova versão, alguns os erros de projeto que dificultavam a manutenção do código-base foram corrigidos, mantendo uns e até introduzindo outros: a documentação ainda é inexistente, ainda não existe componente de gerência de tarefas (lógica de negócio permanece no controlador) e utilizaram padrões de projeto marcados como obsoleto pela própria documentação da linguagem. Como consequência da reescrita, a compatibilidade de mais de 3500 extensões escritas para a plataforma foi quebrada; razões contratuais obrigam alguns desenvolvedores que venderam suas extensões a reescrevê-las para a nova versão sem custo adicional para seus consumidores - mas aqueles extensões disponibilizadas sem custo algum poderão terminar abandonadas.&lt;/p&gt;

&lt;p&gt;Não basta a equipe ser flexível: a solução também tem de ser. Uma documentação bem escrita é importante pois define de maneira acessível os locais onde a solução pode ou não ser estendida. Mudanças e acréscimo de requisitos vão acontecer, pois leis, processos e até a vontade do product owner que definem o comportamento do software mudam; seja durante seu desenvolvimento ou sua manutenção (a menos que o projeto seja abandonado).&lt;/p&gt;

&lt;p&gt;Portanto, acredito que a próxima revolução na Engenharia de Software não virá de uma nova metodologia, mas sim do abandono de velhos vícios de codificação por parte dos programadores. Até lá, podem reescrever o código quantas vezes for necessário: sem previamente desconstruir as más práticas e reconstruir boas práticas no lugar, nada muda. É necessário destruir para construir.&lt;/p&gt;</content><author><name></name></author><summary type="html">Inspirado num artigo escrito no Medium, este post falará o óbvio que “todos” sabem (ou deveriam) e até é ditado popular, mas ignoram mesmo assim: “quem faz malfeito faz duas vezes”.</summary></entry><entry><title type="html">Primeiros contatos com BDD e TDD</title><link href="http://localhost:4000/paulinho/les20171/2017/03/23/primeiros-contatos-com-bdd-e-tdd.html" rel="alternate" type="text/html" title="Primeiros contatos com BDD e TDD" /><published>2017-03-23T09:16:36-03:00</published><updated>2017-03-23T09:16:36-03:00</updated><id>http://localhost:4000/paulinho/les20171/2017/03/23/primeiros-contatos-com-bdd-e-tdd</id><content type="html" xml:base="http://localhost:4000/paulinho/les20171/2017/03/23/primeiros-contatos-com-bdd-e-tdd.html">&lt;h2 id=&quot;geral&quot;&gt;Geral&lt;/h2&gt;

&lt;p&gt;Numa atividade (&lt;a href=&quot;https://github.com/adlerosn/exLes1&quot;&gt;repositório&lt;/a&gt;), foi requisitado programar alguns itens usando BDD e TDD.&lt;/p&gt;

&lt;p&gt;Para demonstrar que é útil, a atividade podia ter parado na segunda questão; a terceira e a quarta questões só serviram para cansar.&lt;/p&gt;

&lt;p&gt;Desenvolver orientado a comportamento e testes se demonstrou útil para repetir uma bateria de testes quando um pequeno erro de lógica (ou digitação?) fazem com que o código tenha um comportamento diferente do esperado, que é convenientemente testado em massa a partir de um único comando no terminal que testa todos os casos fornecidos duma vez só.&lt;/p&gt;

&lt;p&gt;Em contrapartida, escrever o arquivo Gherkin é uma tarefa tediosa que dá desânimo só de pensar que ele terá de ser escrito se mistura ao desânimo de ter de codificar uma solução que não será utilizada; já a parte de traduzir as linhas de Gherkin para um arquivo de testes foi bem mais fluida e menos penosa.&lt;/p&gt;

&lt;p&gt;Portanto, desenvolver com BDD e TDD demonstrou que, embora adicione passos ao desenvolvimento, economiza-se tempo e paciência com tais práticas. Infelizmente, realizar testes unitários em algumas frameworks não é algo trivial e não garante que o usuário aprovará.&lt;/p&gt;

&lt;h2 id=&quot;exercício-1-ar-condicionado&quot;&gt;Exercício 1: Ar condicionado&lt;/h2&gt;

&lt;p&gt;Não ficou claro qual a fórmula que determina a temperatura da sala a partir do ar condicionado; adotei que a média da temperatura estimada da sala com a temperatura no duto de ar é a temperatura percebida pelos alunos.&lt;/p&gt;

&lt;h2 id=&quot;exercício-2-imposto-de-renda&quot;&gt;Exercício 2: Imposto de renda&lt;/h2&gt;

&lt;p&gt;Scenario Outline poupou tempo ao replicar o mesmo caso de teste com campos diferentes.&lt;/p&gt;

&lt;h2 id=&quot;exercício-4-calculadora-em-notação-polonesa-reversa&quot;&gt;Exercício 4: Calculadora em notação polonesa reversa&lt;/h2&gt;

&lt;p&gt;Construir um parser dá trabalho. Usei o “cheat” de expressão regular para ter o tokenizador pronto, mesmo assim ficou maior que esperava.&lt;/p&gt;

&lt;h2 id=&quot;exercício-3-sistema-de-navegação-fictício&quot;&gt;Exercício 3: Sistema de navegação fictício&lt;/h2&gt;

&lt;p&gt;Parser para quê? Um simples matcher resolve o problema com menos dores de cabeça.&lt;/p&gt;

&lt;p&gt;Além disso, não ficou claro como a cidade é selecionada. Assumi que é a cidade cuja coordenada está mais à coordenada geográfica mencionada (north → northmost city; east → eastmost city).&lt;/p&gt;

&lt;h2 id=&quot;padrões-de-projeto&quot;&gt;Padrões de projeto&lt;/h2&gt;

&lt;p&gt;“Tudo em excesso faz mal”. Um problema geralmente “pede” padrão de projeto, ficando mais difícil ou prolixo de resolver caso não utilizado. Em algumas questões, foi tanto padrão de projeto que a solução ficou maior usando padrões do que se não fosse usado.&lt;/p&gt;</content><author><name></name></author><summary type="html">Geral</summary></entry></feed>